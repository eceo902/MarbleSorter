#pragma config(Sensor, in1,	Linefollower,   sensorLineFollower)
#pragma config(Sensor, dgtl2,  LimitSwitch,	sensorTouch)
#pragma config(Sensor, dgtl4,  Quad1,      	sensorQuadEncoder)
#pragma config(Motor,  port9,       	GateServo, 	tmotorServoStandard, openLoop)
#pragma config(Motor,  port10,      	CupMotor,  	tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard           	!!*//
/*
Project Title: 3.3.1 Marble Sorter
Team Members: Eric Simon, Yoon Lee, Evan Seeyave
Date: 4/26/18
Section: Marble Sorting
Task Description: Correctly separate and sort 20 marbles of varying materials
         into bins in 2 minutes or less.
Pseudocode: Detect marble type
      Rotate cup depending on marble type
      Separate one marble out
      Rotate cup back to starting position
      Repeat for each marble
      Stop program after 20 marbles
*/

int marbleIdentity = 0; /* Variable allowing marbles to be assigned specific identities
wood = 1, steel = 2, plastic = 3, clear = 4 -- Zero is the starting value
*/
int woodThreshold = 195; // high threshold that is matched by line follower if marble is wooden
int steelThreshold1 = 850; // low and high thresholds that are matched by line follower if marble is steel
int steelThreshold2 = 1500;
int clearThreshold1 = 1510; // low and high thresholds that are matched by line follower if marble is clear plastic
int clearThreshold2 = 2500; //these are recorded here if needed-- are not used due to "else, ___" statement
int plasticThreshold1 = 196; // low and high thresholds that are matched by line follower if marble is opaque plastic
int plasticThreshold2 = 840;

void simpleClear(){ //this resets the encoder back to the starting position
 while(SensorValue(Quad1) > 0){
  motor[CupMotor] = -20;
 }
}
void moveGate(){ //moves the gate up and down for a very short period of time to separate one marble
  motor[GateServo] = 60; //up
  wait1Msec(75);
  motor[GateServo] = 0; //down
  wait1Msec(300);
  }
void detectMarble(){ /*this procedure will assign marbles specific variable values based on the value read by the line follower
            the "&&" statement ensures that the value is checked by both thresholds */
 if(SensorValue(Linefollower) < woodThreshold){
  marbleIdentity = 1; } //wood
 else if((SensorValue(Linefollower) > steelThreshold1) && (SensorValue(Linefollower) < steelThreshold2)){
  marbleIdentity = 2; } //steel
 else if((SensorValue(Linefollower) > plasticThreshold1) && (SensorValue(Linefollower) < plasticThreshold2)){
  marbleIdentity = 3; } //plastic opaque
 else{
  marbleIdentity = 4; //clear plastic
  }
}
void cupDistance(int degreesToCup){ //procedure that moves the cup plate to the correct position based on the value specified for the procedure
   while(SensorValue(Quad1) < degreesToCup){
  motor[CupMotor] = 30; //fast value to reach the general desired range quickly
    }
    wait1Msec(250);
   while(SensorValue(Quad1) > degreesToCup){
  motor[CupMotor] = -14; //slower, negative value to compensate back and closer to the correct position
    }
    wait1Msec(200);
    while(SensorValue(Quad1) < degreesToCup){ //even slower value to precisely reach the correct position
  motor[CupMotor] = 11;
    }
motor[CupMotor] = 0; //stops the cup plate
}
void cupDistanceFaster(int degreesToCup){ //same procedure but compensates for the added weight of the previous 10 marbles
   while(SensorValue(Quad1) < degreesToCup){
  motor[CupMotor] = 32; //fast value to reach the general desired range quickly
    }
    wait1Msec(250);
   while(SensorValue(Quad1) > degreesToCup){
  motor[CupMotor] = -16; //slower, negative value to compensate back and closer to the correct position
    }
    wait1Msec(200);
    while(SensorValue(Quad1) < degreesToCup){ //even slower value to precisely reach the correct position
  motor[CupMotor] = 11;
    }
motor[CupMotor] = 0; //stops the cup plate
}
void rotateCups(){ //procedure for executing the cup rotating command, "cupDistance" -- distances are assigned based on identities
 if(marbleIdentity == 1){
 cupDistance(90); } //90 degrees for wood
 else if(marbleIdentity == 2){
 cupDistance(180); } // 180 degrees for steel
 else if(marbleIdentity == 3){
 cupDistance(270); } //270 degrees for plastic opaque
 else(cupDistance(360)); //360 degrees for clear plastic
 wait1Msec(10);
        }
void rotateCupsFaster(){ //same procedure but for the faster cupDistance procedure
 if(marbleIdentity == 1){
 cupDistanceFaster(90); } //90 degrees for wood
 else if(marbleIdentity == 2){
 cupDistanceFaster(180); } // 180 degrees for steel
 else if(marbleIdentity == 3){
 cupDistanceFaster(270); } //270 degrees for plastic opaque
 else(cupDistanceFaster(360)); //360 degrees for clear plastic
 wait1Msec(10);
        }
void separationStation(){ //overall program that incorporates all of the procedures
int numMarbles = 0; //starts marble count at zero
 while (numMarbles <=10){ //procedure repeated for each marble
  detectMarble(); //gives marble a value
  rotateCups(); //rotates cups based on value
  wait1Msec(250); //wait to ensure cups are stopped
  numMarbles = numMarbles + 1;
  moveGate(); //drops one marble
    wait1Msec(100); //ensures marble is in cup
simpleClear(); //resets position
  }
  while (numMarbles >10 && numMarbles <=20){ //procedure repeated for each marble
  detectMarble(); //gives marble a value
  rotateCupsFaster(); //rotates cups based on value
  wait1Msec(250); //wait to ensure cups are stopped
  numMarbles = numMarbles + 1;
  moveGate(); //drops one marble
    wait1Msec(100); //ensures marble is in cup
simpleClear(); //resets position
  }

wait1Msec(50); //waits before repeating
}
task main()
{
while (SensorValue[LimitSwitch]== 0){ //idle loop
 }
wait1Msec(100);
SensorValue(Quad1)=0; //resets Quad, "zeroes" it
 wait1Msec(200);
separationStation(); //executes program
}
